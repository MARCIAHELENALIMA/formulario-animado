{"version":3,"names":["Definition","PatternVisitor","OriginalPatternVisitor","Referencer","OriginalReferencer","Scope","ScopeManager","require","getKeys","fallback","visitorKeysMap","getVisitorValues","nodeType","client","FLOW_FLIPPED_ALIAS_KEYS","VISITOR_KEYS","getTypesInfo","flowFlippedAliasKeys","concat","Object","entries","reduce","acc","key","value","includes","propertyTypes","callProperties","type","values","indexers","properties","types","params","argument","elementType","qualification","rest","returnType","typeAnnotation","typeParameters","id","ArrayPattern","node","elements","forEach","visit","ObjectPattern","constructor","options","scopeManager","visitPattern","callback","_checkIdentifierOrVisit","left","processRightHandNodes","visitor","rightHandNodes","visitClass","_visitArray","decorators","typeParamScope","_nestTypeParamScope","_visitTypeAnnotation","implements","superTypeParameters","close","visitFunction","visitProperty","InterfaceDeclaration","_createScopeVariable","extends","body","TypeAlias","right","ClassProperty","_visitClassProperty","ClassPrivateProperty","PropertyDefinition","ClassPrivateMethod","MethodDefinition","DeclareModule","_visitDeclareX","DeclareFunction","DeclareVariable","DeclareClass","OptionalMemberExpression","MemberExpression","name","currentScope","variableScope","__define","parentScope","__currentScope","scope","__nestScope","j","length","apply","arguments","Array","isArray","visitorValues","i","visitorValue","propertyType","nodeProperty","k","loopPropertyNode","l","nodeList","module","exports","analyzeScope","ast","parserOptions","ignoreEval","optimistic","directive","nodejsScope","sourceType","ecmaFeatures","globalReturn","impliedStrict","ecmaVersion","childVisitorKeys","getVisitorKeys","referencer"],"sources":["../src/analyze-scope.cjs"],"sourcesContent":["const {\n  Definition,\n  PatternVisitor: OriginalPatternVisitor,\n  Referencer: OriginalReferencer,\n  Scope,\n  ScopeManager,\n} = process.env.BABEL_8_BREAKING\n  ? require(\"eslint-scope\")\n  : require(\"@nicolo-ribaudo/eslint-scope-5-internals\");\nconst { getKeys: fallback } = require(\"eslint-visitor-keys\");\n\nlet visitorKeysMap;\nfunction getVisitorValues(nodeType, client) {\n  if (visitorKeysMap) return visitorKeysMap[nodeType];\n\n  const { FLOW_FLIPPED_ALIAS_KEYS, VISITOR_KEYS } = client.getTypesInfo();\n\n  const flowFlippedAliasKeys = FLOW_FLIPPED_ALIAS_KEYS.concat([\n    \"ArrayPattern\",\n    \"ClassDeclaration\",\n    \"ClassExpression\",\n    \"FunctionDeclaration\",\n    \"FunctionExpression\",\n    \"Identifier\",\n    \"ObjectPattern\",\n    \"RestElement\",\n  ]);\n\n  visitorKeysMap = Object.entries(VISITOR_KEYS).reduce((acc, [key, value]) => {\n    if (!flowFlippedAliasKeys.includes(value)) {\n      acc[key] = value;\n    }\n    return acc;\n  }, {});\n\n  return visitorKeysMap[nodeType];\n}\n\nconst propertyTypes = {\n  // loops\n  callProperties: { type: \"loop\", values: [\"value\"] },\n  indexers: { type: \"loop\", values: [\"key\", \"value\"] },\n  properties: { type: \"loop\", values: [\"argument\", \"value\"] },\n  types: { type: \"loop\" },\n  params: { type: \"loop\" },\n  // single property\n  argument: { type: \"single\" },\n  elementType: { type: \"single\" },\n  qualification: { type: \"single\" },\n  rest: { type: \"single\" },\n  returnType: { type: \"single\" },\n  // others\n  typeAnnotation: { type: \"typeAnnotation\" },\n  typeParameters: { type: \"typeParameters\" },\n  id: { type: \"id\" },\n};\n\nclass PatternVisitor extends OriginalPatternVisitor {\n  ArrayPattern(node) {\n    node.elements.forEach(this.visit, this);\n  }\n\n  ObjectPattern(node) {\n    node.properties.forEach(this.visit, this);\n  }\n}\n\nclass Referencer extends OriginalReferencer {\n  #client;\n\n  constructor(options, scopeManager, client) {\n    super(options, scopeManager);\n    this.#client = client;\n  }\n\n  // inherits.\n  visitPattern(node, options, callback) {\n    if (!node) {\n      return;\n    }\n\n    // Visit type annotations.\n    this._checkIdentifierOrVisit(node.typeAnnotation);\n    if (node.type === \"AssignmentPattern\") {\n      this._checkIdentifierOrVisit(node.left.typeAnnotation);\n    }\n\n    // Overwrite `super.visitPattern(node, options, callback)` in order to not visit `ArrayPattern#typeAnnotation` and `ObjectPattern#typeAnnotation`.\n    if (typeof options === \"function\") {\n      callback = options;\n      options = { processRightHandNodes: false };\n    }\n\n    const visitor = new PatternVisitor(this.options, node, callback);\n    visitor.visit(node);\n\n    // Process the right hand nodes recursively.\n    if (options.processRightHandNodes) {\n      visitor.rightHandNodes.forEach(this.visit, this);\n    }\n  }\n\n  // inherits.\n  visitClass(node) {\n    // Decorators.\n    this._visitArray(node.decorators);\n\n    // Flow type parameters.\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // Flow super types.\n    this._visitTypeAnnotation(node.implements);\n    this._visitTypeAnnotation(\n      node.superTypeParameters && node.superTypeParameters.params,\n    );\n\n    // Basic.\n    super.visitClass(node);\n\n    // Close the type parameter scope.\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  // inherits.\n  visitFunction(node) {\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // Flow return types.\n    this._checkIdentifierOrVisit(node.returnType);\n\n    // Basic.\n    super.visitFunction(node);\n\n    // Close the type parameter scope.\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  // inherits.\n  visitProperty(node) {\n    if (node.value?.type === \"TypeCastExpression\") {\n      this._visitTypeAnnotation(node.value);\n    }\n    this._visitArray(node.decorators);\n    super.visitProperty(node);\n  }\n\n  InterfaceDeclaration(node) {\n    this._createScopeVariable(node, node.id);\n\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    // TODO: Handle mixins\n    this._visitArray(node.extends);\n    this.visit(node.body);\n\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  TypeAlias(node) {\n    this._createScopeVariable(node, node.id);\n\n    const typeParamScope = this._nestTypeParamScope(node);\n\n    this.visit(node.right);\n\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  ClassProperty(node) {\n    this._visitClassProperty(node);\n  }\n\n  ClassPrivateProperty(node) {\n    this._visitClassProperty(node);\n  }\n\n  PropertyDefinition(node) {\n    this._visitClassProperty(node);\n  }\n\n  // TODO: Update to visit type annotations when TypeScript/Flow support this syntax.\n  ClassPrivateMethod(node) {\n    super.MethodDefinition(node);\n  }\n\n  DeclareModule(node) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareFunction(node) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareVariable(node) {\n    this._visitDeclareX(node);\n  }\n\n  DeclareClass(node) {\n    this._visitDeclareX(node);\n  }\n\n  // visit OptionalMemberExpression as a MemberExpression.\n  OptionalMemberExpression(node) {\n    super.MemberExpression(node);\n  }\n\n  _visitClassProperty(node) {\n    this._visitTypeAnnotation(node.typeAnnotation);\n    this.visitProperty(node);\n  }\n\n  _visitDeclareX(node) {\n    if (node.id) {\n      this._createScopeVariable(node, node.id);\n    }\n\n    const typeParamScope = this._nestTypeParamScope(node);\n    if (typeParamScope) {\n      this.close(node);\n    }\n  }\n\n  _createScopeVariable(node, name) {\n    this.currentScope().variableScope.__define(\n      name,\n      new Definition(\"Variable\", name, node, null, null, null),\n    );\n  }\n\n  _nestTypeParamScope(node) {\n    if (!node.typeParameters) {\n      return null;\n    }\n\n    const parentScope = this.scopeManager.__currentScope;\n    const scope = new Scope(\n      this.scopeManager,\n      \"type-parameters\",\n      parentScope,\n      node,\n      false,\n    );\n\n    this.scopeManager.__nestScope(scope);\n    for (let j = 0; j < node.typeParameters.params.length; j++) {\n      const name = node.typeParameters.params[j];\n      scope.__define(name, new Definition(\"TypeParameter\", name, name));\n      if (name.typeAnnotation) {\n        this._checkIdentifierOrVisit(name);\n      }\n    }\n    scope.__define = function () {\n      return parentScope.__define.apply(parentScope, arguments);\n    };\n\n    return scope;\n  }\n\n  _visitTypeAnnotation(node) {\n    if (!node) {\n      return;\n    }\n    if (Array.isArray(node)) {\n      node.forEach(this._visitTypeAnnotation, this);\n      return;\n    }\n\n    // get property to check (params, id, etc...)\n    const visitorValues = getVisitorValues(node.type, this.#client);\n    if (!visitorValues) {\n      return;\n    }\n\n    // can have multiple properties\n    for (let i = 0; i < visitorValues.length; i++) {\n      const visitorValue = visitorValues[i];\n      const propertyType = propertyTypes[visitorValue];\n      const nodeProperty = node[visitorValue];\n      // check if property or type is defined\n      if (propertyType == null || nodeProperty == null) {\n        continue;\n      }\n      if (propertyType.type === \"loop\") {\n        for (let j = 0; j < nodeProperty.length; j++) {\n          if (Array.isArray(propertyType.values)) {\n            for (let k = 0; k < propertyType.values.length; k++) {\n              const loopPropertyNode = nodeProperty[j][propertyType.values[k]];\n              if (loopPropertyNode) {\n                this._checkIdentifierOrVisit(loopPropertyNode);\n              }\n            }\n          } else {\n            this._checkIdentifierOrVisit(nodeProperty[j]);\n          }\n        }\n      } else if (propertyType.type === \"single\") {\n        this._checkIdentifierOrVisit(nodeProperty);\n      } else if (propertyType.type === \"typeAnnotation\") {\n        this._visitTypeAnnotation(node.typeAnnotation);\n      } else if (propertyType.type === \"typeParameters\") {\n        for (let l = 0; l < node.typeParameters.params.length; l++) {\n          this._checkIdentifierOrVisit(node.typeParameters.params[l]);\n        }\n      } else if (propertyType.type === \"id\") {\n        if (node.id.type === \"Identifier\") {\n          this._checkIdentifierOrVisit(node.id);\n        } else {\n          this._visitTypeAnnotation(node.id);\n        }\n      }\n    }\n  }\n\n  _checkIdentifierOrVisit(node) {\n    if (node?.typeAnnotation) {\n      this._visitTypeAnnotation(node.typeAnnotation);\n    } else if (node?.type === \"Identifier\") {\n      this.visit(node);\n    } else {\n      this._visitTypeAnnotation(node);\n    }\n  }\n\n  _visitArray(nodeList) {\n    if (nodeList) {\n      for (const node of